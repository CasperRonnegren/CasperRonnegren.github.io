<!DOCTYPE HTML>
<html>
	<head>
		<title>Casper Portfolio</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload landing">
		<div id="page-wrapper">
			
			<!-- Banner -->
			<section id="banner">
				<div class="content">
					<header>
						<h2>Casper Ronnegren</h2>
						<p>Programmer<br />
						</p>
					</header>
					<span class="image"><img src="images/Katt.jpg" alt="" /></span>
				</div>
			</section>
	
			<!-- Portfolio -->
			<article id="portfolio"> <!-- style="box-shadow: 0 -0.5em 0.5em 0 rgba(0, 0, 0, 0.25);" -->
				<div class="container">
					<header>
						<h2>Some projects I have worked on.</h2>
					</header>
					<div class="row">
		
						<!-- Terrain -->
						<div class="col-4 col-6-medium col-12-small">
							<div class="parent">
							<article class="box style2">
								<a href="Terrain.html" class="image featured"><img loading="lazy" src="images/Terrain/Terrain.png" alt="" style="height: 100%;" /></a>
								<img loading="lazy" class="imageTopRight" src="images/Unreal.png" alt="" width="14%" height ="auto"/>
								<h3 style="text-align: center"><a href="Terrain.html">Procedural Terrain</a></h3>
								<p style="text-align: center">Procedurally generating worlds suitable for games.</p>
							</article>
							</div>
						</div>
		
						<!-- Multiplayer -->
						<div class="col-4 col-6-medium col-12-small">
							<div class="parent">
								<article class="box style2">
									<a href="LowLevelMulti.html" class="image featured"><img loading="lazy"  src="images/Multi/Multi_Game.jpg" alt="" style="height: 100%;" /></a>
									<img loading="lazy" class="imageTopRight" src="images/Unity.png" alt="" width="14%" height ="auto"/>
									<h3 style="text-align: center"><a href="LowLevelMulti.html">Low-Level Multiplayer</a></h3>
									<p style="text-align: center">Building a multiplayer game through Unity Transport.</p>
								</article>
							</div>
						</div>
		
						<!-- Boids -->
						<div class="col-4 col-6-medium col-12-small">
							<div class="parent">
								<article class="box style2">
									<a href="Boids.html" class="image featured"><img loading="lazy" src="images/Boids/BoidsThumbnail2.png" alt="" style="height: 100%;" /></a>
									<img loading="lazy" class="imageTopRight" src="images/Unity.png" alt="" width="14%" height ="auto"/>
									<h3 style="text-align: center"><a href="Boids.html">Optimizing Boids</a></h3>
									<p style="text-align: center">Using Unity DOTS to create and optimize Boids.</p>
								</article>
							</div>
						</div>
		
						<!-- Group -->
						<div class="col-4 col-6-medium col-12-small">
							<div class="parent">
								<article class="box style2">
									<a href="index.html" class="image featured"><img loading="lazy" src="images/Group/GroupThumbnail.png" alt="" style="height: 100%;" /></a>
									<img loading="lazy" class="imageTopRight" src="images/Unity.png" alt="" width="14%" height ="auto"/>
									<h3 style="text-align: center"><a href="index.html">Card Battler</a></h3>
									<p style="text-align: center">(Still Writing)<!--Creating a card battler for a larger group project.--></p>
								</article>
							</div>
						</div>
					</div>
				</div>
			</article>
			
			<article id="Blog">
				<div class="container">
					<div class="row gtr-150">
						<header>
							<h2 style="margin-bottom: 0.15em">Recent Stuff</h2>
						</header>
						<div class="col-12 col-12-medium"><hr/></div>
						<h3>Dynamic Tile Grid</h3>
						<b class="image fit"><img loading="lazy" src="images/Blog/TileGrid.png" alt="" /></b>
						<p>
							Recently, I decided to begin working on a game I've conceptualized in my head for a while now. 
							A central mechanic to that game involves being able to place constructs on the tiles of a grid.
							The player is only intended be able to build at designated locations, so it needs to be possible to place the grids within the world itself.
							Additionally, unlike the typical rectangle shaped grid, I also wanted to be able to pick and choose which tiles are included within the grid, so they can be adapted to the locations they're placed at.
							I've been ruminating on what would be a reasonable way of programming this for a while now, and the conclusion I've come to is to throw a 
							<a href="https://youtu.be/kVgy1GSDHG8?t=215">HashMap</a> at the problem.
						</p>
						<p>
							In short, the HashMap contains items where the key is a 2D coordinate representing a tile on the grid and the value is a reference to the current construct placed on the tile, 
							which is null if no construct is placed.
							The grid itself is made through a <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/geometry-scripting-users-guide-in-unreal-engine">Dynamic Mesh</a>.
							To generate the geometry of the mesh, I do a foreach loop on the HashMap and create a border for every 2D coordinate.
							Part of the reason as to why I chose to use a HashMap is because it makes it easy to tell the class where to not generate a tile, 
							as all you have to do is remove the Tile/Coordinate from the HashMap!
							The other part is because it makes it easy to later on program functionality like placing a construct at a coordinate or checking what is placed at a coordinate, 
							all with that sweet O(1) lookup time complexity.
						</p>
						<p>
							Individually adding/removing coordinates/tiles from a HashMap would be quite tiresome, so I also decided to explore if I could make an in-editor tool that allows me to just click a tile
							to add or remove it from the HashMap.
							Fortunately, all this could be done through <a href="https://dev.epicgames.com/community/learning/tutorials/KP5p/unreal-engine-extending-unreal-editor-with-component-visualizer">Component Visualizers</a>.
							The end result looks like this:
						</p>
						<b class="image fit"><img loading="lazy" src="images/Blog/TileGridEditor.png" alt="" /></b>
						<p>
							Green represents tiles in the HashMap, red represents tiles not in it. Clicking any tile swaps it between green and red.
						</p>
						<p>
							Overall, visualizers were pretty straight to work with, until they were not.
							Drawing a line with the provided <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Engine/FPrimitiveDrawInterface?application_version=5.5">PrimitiveDrawInterface</a> 
							class was the typical: a start coordinate, an end coordinate, and a color.
							Drawing a filled rectangle proved a little bit more difficult as the 
							<a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Engine/FPrimitiveDrawInterface?application_version=5.5">DrawRectangleFunction</a> 
							required a <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Engine/FMaterialRenderProxy?application_version=5.6">MaterialRenderProxy</a>, 
							a class I hadn't encountered before.
							As such, I decided to consult the Unreal API documentation to get answers for questions like: <br>
							&nbsp;•&nbsp; What is a MaterialRenderProxy? <br>
							&nbsp;•&nbsp; How do I get one? <br>
							&nbsp;•&nbsp; Why won't a regular material suffice? <br> 
							So what are the answers? 
							Well, according to the <i>all so useful</i> Unreal API documentation, a MaterialRenderProxy is explained as: "<i>A material render proxy used by the renderer.</i>"
						</p>
						<div class="col-4 col-12-medium"><b class="image fit"><img loading="lazy" src="images/Blog/My_Goodness_What_an_Idea.jpg" alt="" /></b></div>
						<div class="col-4 col-12-medium"></div>
						<div class="col-4 col-12-medium"></div>
						<p>
							Beyond that sentence, there was no further explanation to be found.
							Eventually, I figured out that it's possible to get a MaterialRenderProxy by just calling the "GetRenderProxy()" function of any material.
							Testing a couple for the DrawRectangleMesh function, I found that using any material with "Used with Editor Composting" set to true will work as a MaterialRenderProxy for the function.
							Though, you specifically want a material using vertex painting as that is how the color set in the DrawRectangleMesh function is applied 
							— a fun fact that is NOT mentioned in the documentation and which I found out by digging through the engine code.
							Another fun fact: to even have half the functions you can override in 
							<a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Editor/UnrealEd/FComponentVisualizer?application_version=5.5">FComponentVisualizer</a> 
							work, you need to override "virtual bool IsVisualizingArchetype() const" and make it return true — 
							something that is also conveniently mentioned NOWHERE in the documentation.
						</p>
						<p>
							Other than the lacking documentation, Component Visualizers work well.
							The only disappointment I had is that there doesn't seem to be any function to override for hovering over visualizers, only ones for clicking them.
							And, if one is to be so bold and try to use the function that visualizers use internally for providing what is clicked (GetHitProxy), 
							the engine itself will see that as a personal insult and commit suicide.
							So, unfortunately, I didn't really bother going further than that to try and get hover functionality to work since it wasn't really necessary in the first place — it would just be nice to have.
						</p>
						<div class="col-4 col-12-medium"><b class="image fit"><img loading="lazy" src="images/Blog/Rows.png" alt="" /></b></div>
						<div class="col-4 col-12-medium"><b class="image fit"><img loading="lazy" src="images/Blog/Columns.png" alt="" /></b></div>
						<div class="col-4 col-12-medium"><b class="image fit"><img loading="lazy" src="images/Blog/RowsColumns.png" alt="" /></b></div>
						<p>
							<b class="image floatRight" style="width: 6.3em;"><img loading="lazy" src="images/Blog/UglyTileGrid.png" alt="" /></b>
							Finally, about the grid itself!
							More specifically, how it's presented in the world.
							I spent quite some time pondering what I wanted the grid to look like and how I would go about achieving that look.
							My first idea was to have every tile generate the geometry for its own borders, resulting in 8 triangles per tile.
							The benefit of this approach is that it would make it easy to add/remove or just highlight individual tiles on the mesh.
							I ended up not doing this because I found that having lines essentially be "half thickness" just didn't look very appealing when I tried it.
						</p>
						<p>
							What I ended up doing was the standard approach of drawing long lines of rows and columns which end up forming tiles between them.
							This has the benefit of being more performant as it results in significantly less geometry as you only need 2 triangles for each line.
							However, the difficult part in my case is that the grid has to be able to have tiles missing within it, so I couldn't just go the easy route of
							specifying X amount of columns and Y amount of rows.
							I had to figure out an algorithm to traverse between tiles to find out how long each line can be, which wasn't as easy as I thought it would be.
							Of course, I could've also achieved the same look with the former approach by just doubling the thickness of the borders outwards and thereby
							having the geometry of the tiles overlap, but I wouldn't get benefits of having less geometry.
							Also, it would feel like commiting a cardinal sin in the modelling space.
						</p>
						<p>
							<b class="image floatRight" style="width: 5.1em;"><img loading="lazy" src="images/Blog/OffsetAlongNormals.png" alt="" /></b>
							As for the grid shader, initially, I only intended to apply an unlit one and call it a day.
							However, while working on the grid system, I came to notice that all outlines in Unreal, and lines drawn with Component Visualizers, are still perfectly
							visible no matter how far away you view them from.
							That is to say, they scale with distance.
							I wanted to replicate that behaviour, and it proved rather easy to do as all that had to be done was to offset the vertices for the lines along their normals
							depending on distance/depth.
							Of course, prior to this the mesh didn't have any normals set, but this was only a matter of finding the result of a normalized diagonal vector for each corner.
							The results can be seen below.
						</p>
						<div class="col-6 col-12-medium"><a href="images/Blog/DepthScale.png" class="image fit"><img loading="lazy" src="images/Blog/DepthScale.png" alt="" /></a></div>
						<div class="col-6 col-12-medium"><a href="images/Blog/NoDepthScale.png" class="image fit"><img loading="lazy" src="images/Blog/NoDepthScale.png" alt="" /></a></div>
						<p>
							The greatest benefit I would say is that it improves upon aliasing which otherwise becomes much more noticeable with distance (click on the image if it's hard to see).
						</p>
						<p>
							At this point when working on the shader, I had an idea.
							An idea I have no clue as to how I got.
							If I am already using normals to offset the vertices in order to scale the lines, would it not be possible to rotate the offset vectors to face the viewer?
							Through this, I would be able to have the lines that are drawn essentially be the same thickness regardless of what angle or distance they are viewed from.
							This is an idea that is only applicable to in this situation because the lines in the mesh themselves are flat.
							I felt absolutely ingenious when I came up with this, as if the spirit of Ben Cloward himself had guided me towards this answer.
							The results can be seen below.
						</p>
						<div class="col-6 col-12-medium"><a href="images/Blog/RotatedDepthScale.png" class="image fit"><img loading="lazy" src="images/Blog/RotatedDepthScale.png" alt="" /></a></div>
						<div class="col-6 col-12-medium"><a href="images/Blog/DepthScale.png" class="image fit"><img loading="lazy" src="images/Blog/DepthScale.png" alt="" /></a></div>
						<p>
							This is the current point I am in this project right now.
							There were some small visual oddities when I tried rotating the offset vectors, but I've managed to hide them pretty well after some experimentation.
							Next I will be working on adding some gameplay functionality to the grid.
						</p>
						<p style="margin-bottom: 0">
							Originally I didn't intend to write this much — only a couple words and a picture of the project I had been working on over the weekend 
							— but I felt inspired wanting to complain about the Unreal documentation.
						</p>
						
						<div class="col-12 col-12-medium"><hr/></div>
						<h3>Drawable Portal</h3>
						<b class="image fit"><img loading="lazy" src="images/Blog/DrawablePortal.gif" alt="" /></b>
						<p style="margin-bottom: 0">
							Something I made by combining 
							<a href="https://www.youtube.com/watch?v=cWpFZbjtSQg">this</a>,
							<a href="https://www.youtube.com/watch?v=YUWfHX_ZNCw">this</a>, and 
							<a href="https://stackoverflow.com/questions/35574227/unity-shader-highlighting-overlaps">this</a>
							because I wanted to see if it was possible.
						</p>
					</div>

					<div class="col-12 col-12-medium"><hr/></div>
					<p style="margin-bottom: 50px">You've reached the end.</p>
				</div>
			</article>
			
			<!--<article id="Blog" style="background-color: #1a1b23; box-shadow: 0 -0.5em 0.5em 0 rgba(0, 0, 0, 0.25);">
				<div class="container">
					<header>
						<h2>Recent Stuff</h2>
					</header>
					<p style="margin-bottom: 0">
						Wasd
					</p>
				</div>
			</article>-->
		</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/jquery.dropotron.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>
	</body>
</html>